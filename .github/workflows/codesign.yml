name: Build and Sign EXE with DigiCert STM

on:
  push:
    branches: ["main"]
  workflow_dispatch:

jobs:
  build-and-sign:
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.0.x"

      - name: Build test EXE
        shell: pwsh
        run: |
          dotnet new console -n HelloSTM -o HelloSTM
          dotnet publish HelloSTM -c Release -r win-x64 --self-contained true -p:PublishSingleFile=true -o out
          if (!(Test-Path "out\HelloSTM.exe")) {
            Get-ChildItem -Recurse out
            throw "Expected out\HelloSTM.exe not found."
          }
          Write-Host "Built: out\HelloSTM.exe"

      - name: Write SM client certificate to disk
        shell: pwsh
        run: |
          $p12Path = Join-Path $env:RUNNER_TEMP "sm_client_cert.p12"
          $bytes = [Convert]::FromBase64String("${{ secrets.SM_CLIENT_CERT_FILE_B64 }}")
          [IO.File]::WriteAllBytes($p12Path, $bytes)

          if (!(Test-Path $p12Path)) { throw "Client cert file was not created: $p12Path" }

          "SM_CLIENT_CERT_FILE=$p12Path" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding ascii
          Write-Host "Client cert written to: $p12Path"

      # Deterministic debug: use the SAME env vars smctl will use
      - name: Debug STM env + validate client-auth cert (safe)
        shell: pwsh
        env:
          SM_HOST: ${{ secrets.SM_HOST }}
          SM_API_KEY: ${{ secrets.SM_API_KEY }}
          SM_CLIENT_CERT_PASSWORD: ${{ secrets.SM_CLIENT_CERT_PASSWORD }}
          SM_CLIENT_CERT_FILE: ${{ env.SM_CLIENT_CERT_FILE }}
        run: |
          if ([string]::IsNullOrWhiteSpace($env:SM_HOST)) { throw "SM_HOST secret is missing/empty" }
          if ($env:SM_HOST -notmatch "clientauth") { throw "SM_HOST must be a clientauth URL (mTLS/MFA). Current value doesn't contain 'clientauth'." }
          if ([string]::IsNullOrWhiteSpace($env:SM_API_KEY)) { throw "SM_API_KEY secret is missing/empty" }
          if ([string]::IsNullOrWhiteSpace($env:SM_CLIENT_CERT_PASSWORD)) { throw "SM_CLIENT_CERT_PASSWORD secret is missing/empty" }
          if ([string]::IsNullOrWhiteSpace($env:SM_CLIENT_CERT_FILE)) { throw "SM_CLIENT_CERT_FILE env is missing" }
          if (!(Test-Path $env:SM_CLIENT_CERT_FILE)) { throw "Client cert file not found at $env:SM_CLIENT_CERT_FILE" }

          Write-Host "SM_HOST is set"
          Write-Host "Client cert file exists"

          # Safe inspection: show that the P12 contains a cert intended for client auth
          # (this prints EKU and subject; no private key is output)
          certutil -dump $env:SM_CLIENT_CERT_FILE | Select-String -Pattern "Enhanced Key Usage|Client Authentication|Subject:|Issuer:" -Context 0,2

      - name: Verify P12 contains Client Authentication cert (safe)
        shell: pwsh
        env:
          SM_CLIENT_CERT_FILE: ${{ env.SM_CLIENT_CERT_FILE }}
          SM_CLIENT_CERT_PASSWORD: ${{ secrets.SM_CLIENT_CERT_PASSWORD }}
        run: |
          if (!(Test-Path $env:SM_CLIENT_CERT_FILE)) { throw "Missing P12 at $env:SM_CLIENT_CERT_FILE" }
      
          # Use OpenSSL (available via Git on windows-latest) to inspect the cert inside the P12
          $openssl = "C:\Program Files\Git\usr\bin\openssl.exe"
          if (!(Test-Path $openssl)) { $openssl = "openssl" }
      
          & $openssl pkcs12 -in $env:SM_CLIENT_CERT_FILE -nokeys -passin pass:$env:SM_CLIENT_CERT_PASSWORD |
            Select-String -Pattern "Subject:|Issuer:|X509v3 Extended Key Usage|Client Authentication" -Context 0,2


      - name: Setup Software Trust Manager + Sign
        uses: digicert/code-signing-software-trust-action@main
        with:
          simple-signing-mode: true
          input: out/HelloSTM.exe
          keypair-alias: PrivateKeyPair
        env:
          SM_HOST: ${{ secrets.SM_HOST }}
          SM_API_KEY: ${{ secrets.SM_API_KEY }}
          SM_CLIENT_CERT_FILE: ${{ env.SM_CLIENT_CERT_FILE }}
          SM_CLIENT_CERT_PASSWORD: ${{ secrets.SM_CLIENT_CERT_PASSWORD }}

      - name: Upload signed EXE
        uses: actions/upload-artifact@v4
        with:
          name: HelloSTM-signed
          path: out/HelloSTM.exe
