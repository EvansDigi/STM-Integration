name: Build and Sign EXE with DigiCert STM

on:
  push:
    branches: ["main"]
  workflow_dispatch:

jobs:
  build-and-sign:
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # 1) Build a real Windows EXE (single-file)
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.0.x"

      - name: Build test EXE
        shell: pwsh
        run: |
          dotnet new console -n HelloSTM -o HelloSTM
          dotnet publish HelloSTM -c Release -r win-x64 --self-contained true -p:PublishSingleFile=true -o out
          if (!(Test-Path "out\HelloSTM.exe")) {
            Get-ChildItem -Recurse out
            throw "Expected out\HelloSTM.exe not found."
          }
          Write-Host "Built: out\HelloSTM.exe"

      # 2) Recreate the STM client cert file on the runner from Base64 secret
      #    (so it can be used as MFA client authentication cert)
      - name: Write SM client certificate to disk
        shell: pwsh
        run: |
          $p12Path = Join-Path $env:RUNNER_TEMP "sm_client_cert.p12"
          $bytes = [Convert]::FromBase64String("${{ secrets.SM_CLIENT_CERT_FILE_B64 }}")
          [IO.File]::WriteAllBytes($p12Path, $bytes)

          if (!(Test-Path $p12Path)) { throw "Client cert file was not created: $p12Path" }

          # Persist path for later steps
          "SM_CLIENT_CERT_FILE=$p12Path" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding ascii
          Write-Host "Client cert written to: $p12Path"

      # 3) Quick sanity check (no secrets printed)
      - name: Debug STM env (safe)
        shell: pwsh
        run: |
          if ("${{ secrets.SM_HOST }}") { Write-Host "SM_HOST is set (from secrets)" } else { throw "SM_HOST secret is missing/empty" }
          if ("${{ secrets.SM_API_KEY }}") { Write-Host "SM_API_KEY is set (from secrets)" } else { throw "SM_API_KEY secret is missing/empty" }
          if ($env:SM_CLIENT_CERT_FILE) { Write-Host "SM_CLIENT_CERT_FILE is set: $env:SM_CLIENT_CERT_FILE" } else { throw "SM_CLIENT_CERT_FILE missing" }
          if (Test-Path $env:SM_CLIENT_CERT_FILE) { Write-Host "Client cert file exists" } else { throw "Client cert file not found" }

      # 4) Setup STM + Sign using the DigiCert GitHub Action (simple signing mode)
      #    The action expects SM_HOST / SM_API_KEY / SM_CLIENT_CERT_FILE / SM_CLIENT_CERT_PASSWORD. :contentReference[oaicite:1]{index=1}
      - name: Setup Software Trust Manager + Sign
        uses: digicert/code-signing-software-trust-action@main
        with:
          simple-signing-mode: true
          input: out/HelloSTM.exe
          keypair-alias: PrivateKeyPair
        env:
          SM_HOST: ${{ secrets.SM_HOST }}
          SM_API_KEY: ${{ secrets.SM_API_KEY }}
          SM_CLIENT_CERT_FILE: ${{ env.SM_CLIENT_CERT_FILE }}
          SM_CLIENT_CERT_PASSWORD: ${{ secrets.SM_CLIENT_CERT_PASSWORD }}

      # 5) Upload artifacts so you can download the signed EXE from the run
      - name: Upload signed EXE
        uses: actions/upload-artifact@v4
        with:
          name: HelloSTM-signed
          path: out/HelloSTM.exe
